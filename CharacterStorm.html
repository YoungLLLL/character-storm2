<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>字符风暴</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#1a1a2e',
                    },
                    fontFamily: {
                        matrix: ['Courier New', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .glass {
                background: rgba(255, 255, 255, 0.05);
                backdrop-filter: blur(8px);
                -webkit-backdrop-filter: blur(8px);
            }
            .btn-hover {
                transition: all 0.3s ease;
            }
            .btn-hover:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }
        }
    </style>
    <style>
        body {
            overflow: hidden;
            touch-action: manipulation;
        }
        #canvas {
            display: block; /* 移除鼠标隐藏样式 */
        }
        /* 加载动画 */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        .loader span {
            color: #fff;
            font-family: 'matrix', monospace;
            font-size: 2em;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body class="bg-black m-0 p-0">
    <!-- 加载动画 -->
    <div class="loader" id="loader">
        <span>LOADING...</span>
    </div>

    <canvas id="canvas" class="w-full h-screen"></canvas>
    
    <!-- 控制按钮 -->
    <div class="absolute top-4 right-4 z-10 flex flex-col gap-3">
        <button id="togglePause" class="glass px-4 py-2 rounded-full text-white border border-white/20 btn-hover">
            <i class="fa fa-pause"></i>
        </button>
        <button id="resetButton" class="glass px-4 py-2 rounded-full text-white border border-white/20 btn-hover">
            <i class="fa fa-refresh"></i>
        </button>
        <button id="infoButton" class="glass px-4 py-2 rounded-full text-white border border-white/20 btn-hover">
            <i class="fa fa-info"></i>
        </button>
    </div>
    
    <!-- 信息弹窗 -->
    <div id="infoModal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-20 hidden flex items-center justify-center p-4">
        <div class="glass rounded-xl p-6 max-w-md w-full border border-white/10">
            <h3 class="text-white text-xl font-bold mb-4">字符风暴</h3>
            <ul class="text-white/80 space-y-2 text-sm">
                <li><i class="fa fa-hand-pointer-o mr-2 text-blue-400"></i>点击屏幕生成掉落单词</li>
                <li><i class="fa fa-space-shuttle mr-2 text-yellow-400"></i>按空格键暂停/继续</li>
                <li><i class="fa fa-refresh mr-2 text-purple-400"></i>重置按钮清空所有内容</li>
                <li><i class="fa fa-pause mr-2 text-red-400"></i>暂停按钮停止动画</li>
            </ul>
            <button id="closeInfo" class="mt-6 w-full py-2 rounded-lg bg-white/10 text-white hover:bg-white/20 transition-colors">
                开始体验
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 加载动画
            const loader = document.getElementById('loader');
            const infoModal = document.getElementById('infoModal');
            const closeInfo = document.getElementById('closeInfo');
            const infoButton = document.getElementById('infoButton');
            
            // 显示加载动画2秒后隐藏
            setTimeout(() => {
                loader.style.opacity = '0';
                setTimeout(() => {
                    loader.style.display = 'none';
                    // 显示信息弹窗
                    infoModal.classList.remove('hidden');
                }, 500);
            }, 1500);
            
            // 信息弹窗控制
            closeInfo.addEventListener('click', () => {
                infoModal.classList.add('hidden');
            });
            
            infoButton.addEventListener('click', () => {
                infoModal.classList.remove('hidden');
            });
            
            // Canvas设置
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const togglePauseBtn = document.getElementById('togglePause');
            const resetButton = document.getElementById('resetButton');
            const pauseIcon = togglePauseBtn.querySelector('i');
            
            // 设置Canvas尺寸
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 字符集
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:\'",.<>/?';
            
            // 常用英文单词库
            const englishWords = [
                "hello", "world", "apple", "banana", "computer", "internet", 
                "science", "nature", "music", "art", "history", "future",
                "freedom", "happiness", "love", "friend", "family", "home",
                "water", "fire", "earth", "air", "sun", "moon", "star",
                "time", "space", "light", "dark", "day", "night", "life",
                "death", "beginning", "end", "journey", "destination", "dream",
                "reality", "truth", "lie", "hope", "despair", "courage", "fear",
                "strength", "weakness", "victory", "defeat", "peace", "war",
                "silence", "noise", "order", "chaos", "beauty", "ugliness",
                "wisdom", "foolishness", "wealth", "poverty", "health", "sickness"
            ];
            
            // 粒子类
            class Particle {
                constructor() {
                    this.reset();
                }
                
                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 10 + 12;
                    this.speedX = Math.random() * 1 - 1.5;
                    this.speedY = Math.random() * 1 - 1.5;
                    this.angle = Math.random() * Math.PI * 2;
                    this.spin = Math.random() * 0.1 - 0.05;
                    this.char = characters.charAt(Math.floor(Math.random() * characters.length));
                    this.color = this.getRandomColor();
                    this.life = 1;
                    this.fadeSpeed = Math.random() * 0.005 + 0.001;
                }
                
                getRandomColor() {
                    const colors = [
                        '#FF5E5E', '#FF7D5E', '#FFB347', '#FFF275', 
                        '#93FF96', '#42D7F5', '#7D5FFF', '#C774E8'
                    ];
                    return colors[Math.floor(Math.random() * colors.length)];
                }
                
                update() {
                    this.x += this.speedX * Math.cos(this.angle);
                    this.y += this.speedY * Math.sin(this.angle);
                    this.angle += this.spin;
                    this.life -= this.fadeSpeed;
                    
                    if (this.life <= 0 || 
                        this.x < -this.size || 
                        this.x > canvas.width + this.size || 
                        this.y < -this.size || 
                        this.y > canvas.height + this.size) {
                        this.reset();
                    }
                }
                
                draw() {
                    ctx.save();
                    ctx.font = `${this.size}px matrix`;
                    ctx.fillStyle = this.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = this.life;
                    
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    
                    ctx.fillText(this.char, this.x, this.y);
                    ctx.restore();
                }
            }
            
            // 掉落单词类
            class FallingWord {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.word = englishWords[Math.floor(Math.random() * englishWords.length)];
                    this.size = 30 + Math.random() * 8;
                    this.speedY = 4 + Math.random() * 2;
                    this.rotation = 0;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.05;
                    this.color = this.getRandomColor();
                    this.landed = false;
                    this.stackPosition = 0;
                }
                
                getRandomColor() {
                    const colors = [
                        '#FF5E5E', '#FF7D5E', '#FFB347', '#FFF275', 
                        '#93FF96', '#42D7F5', '#7D5FFF', '#C774E8'
                    ];
                    return colors[Math.floor(Math.random() * colors.length)];
                }
                
                update(stackedWords) {
                    if (!this.landed) {
                        const groundY = canvas.height - this.size - 10;
                        
                        if (this.y >= groundY) {
                            this.y = groundY;
                            this.landed = true;
                            this.stackPosition = stackedWords.filter(w => w.landed).length;
                            return true;
                        }
                        
                        for (let word of stackedWords) {
                            if (word.landed && word !== this) {
                                const wordWidth = ctx.measureText(word.word).width;
                                const thisWidth = ctx.measureText(this.word).width;
                                
                                if (this.x < word.x + wordWidth/2 && 
                                    this.x + thisWidth/2 > word.x &&
                                    this.y + this.size/2 > word.y - word.size/2 &&
                                    this.y < word.y) {
                                    this.y = word.y - word.size/2 - this.size/2;
                                    this.landed = true;
                                    this.stackPosition = stackedWords.filter(w => w.landed).length;
                                    return true;
                                }
                            }
                        }
                        
                        this.y += this.speedY;
                        this.rotation += this.rotationSpeed;
                    } else {
                        this.rotation = Math.sin(Date.now() * 0.001 + this.stackPosition) * 0.05;
                    }
                    
                    return true;
                }
                
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.font = `${this.size}px matrix`;
                    ctx.fillStyle = this.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                    
                    ctx.fillText(this.word, 0, 0);
                    ctx.restore();
                }
            }
            
            // 初始化粒子和单词数组
            let particles = [];
            let fallingWords = [];
            const particleCount = 300;
            
            function initialize() {
                particles = [];
                fallingWords = [];
                
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle());
                }
            }
            
            initialize();
            
            // 动画变量
            let isPaused = false;
            let animationId;
            
            // 动画循环
            function animate() {
                if (!isPaused) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    const bgGradient = ctx.createRadialGradient(
                        canvas.width / 2, canvas.height / 2, 0,
                        canvas.width / 2, canvas.height / 2, canvas.width
                    );
                    bgGradient.addColorStop(0, '#050505');
                    bgGradient.addColorStop(1, '#000000');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    particles.forEach(particle => {
                        particle.update();
                        particle.draw();
                    });
                    
                    fallingWords.forEach(word => {
                        word.update(fallingWords);
                        word.draw();
                    });
                }
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
            
            // 暂停/继续按钮
            togglePauseBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                pauseIcon.className = isPaused ? 'fa fa-play' : 'fa fa-pause';
            });
            
            // 重置按钮
            resetButton.addEventListener('click', () => {
                initialize();
            });
            
            // 空格键控制
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    isPaused = !isPaused;
                    pauseIcon.className = isPaused ? 'fa fa-play' : 'fa fa-pause';
                }
            });
            
            // 点击/触摸屏幕生成单词
            function handleScreenInteraction(e) {
                if (infoModal.classList.contains('hidden')) { // 只有在信息弹窗关闭后才响应
                    particles.forEach(particle => {
                        particle.color = particle.getRandomColor();
                    });
                    
                    const rect = canvas.getBoundingClientRect();
                    let x, y;
                    
                    if (e.type.includes('touch')) {
                        x = e.touches[0].clientX - rect.left;
                        y = e.touches[0].clientY - rect.top;
                        e.preventDefault();
                    } else {
                        x = e.clientX - rect.left;
                        y = e.clientY - rect.top;
                    }
                    
                    fallingWords.push(new FallingWord(x, y));
                }
            }
            
            canvas.addEventListener('click', handleScreenInteraction);
            canvas.addEventListener('touchstart', handleScreenInteraction, { passive: false });
            
            // 清理函数
            window.addEventListener('beforeunload', () => {
                cancelAnimationFrame(animationId);
            });
        });
    </script>
</body>
</html>
    